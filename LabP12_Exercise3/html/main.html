<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Frequency Response of FIR Filters: Lab P-12: 3 Lab Exercise</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-11-28">
<meta name="DC.source" content="main.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>Frequency Response of FIR Filters: Lab P-12: 3 Lab Exercise</h1>
<!--introduction-->
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">3.1a)</a>
</li>
<li>
<a href="#13">3.1b)</a>
</li>
<li>
<a href="#14">3.1c)</a>
</li>
<li>
<a href="#15">3.1d)</a>
</li>
<li>
<a href="#20">3.1e)</a>
</li>
<li>
<a href="#21">3.1f)</a>
</li>
<li>
<a href="#22">3.2a)</a>
</li>
<li>
<a href="#24">3.2b)</a>
</li>
<li>
<a href="#29">3.2c)</a>
</li>
<li>
<a href="#30">3.2d)</a>
</li>
<li>
<a href="#31">3.2e)</a>
</li>
<li>
<a href="#32">3.2f)</a>
</li>
</ul>
</div>
<h2 id="1">3.1a)</h2>
<p>We will cascade these filters by convolution, which will be performed by multiplication of their transfer functions.</p>
<p>First we'll find the transfer function of the general filter</p>
<p>Y(z) = X(z) - 2cos(wn)z^-1X(z) + z^-2X(z)</p>
<p>H(z) = 1 - 2cos(wn)z^-1 + z^-2</p>
<p>Now we'll introduce the nulling frequencies 0.44pi and 0.7pi</p>
<p>H1(z) = 1 - 2cos(0.44pi)z^-1 + z^-2</p>
<p>H2(z) = 1 - 2cos(0.7pi)z^-1 + z^-2</p>
<p>Performing the convolution</p>
<p>(1 - 2cos(0.44pi)z^-1 + z^-2)(1 - 2cos(0.44pi)z^-1 + z^-2)</p>
<p>Yields the fourth order filter</p>
<p>1 + (-2cos(0.7pi) - 2cos(0.44pi)))z^-1 + (2 + 4cos(0.44pi)cos(0.7pi))z^-2 + (-2cos(0.44pi) - 2cos(0.7pi))z^-3 + z^-4</p>
<p>Resulting in the following coefficients</p>
<pre class="codeinput">b = [1 -2*cos(0.7*pi)-2*cos(0.44*pi) 2+4*cos(0.44*pi)*cos(0.7*pi) -2*cos(0.44*pi)-2*cos(0.7*pi) 1]
</pre>
<pre class="codeoutput">
b =

    1.0000    0.8008    1.5594    0.8008    1.0000

</pre>
<h2 id="13">3.1b)</h2>
<p>Generate input signal</p>
<pre class="codeinput">n = [0:149];
x = 5*cos(0.3*pi*n) + 22*cos(0.44*pi*n-pi/3) + 22*cos(0.7*pi*n-pi/4);
</pre>
<h2 id="14">3.1c)</h2>
<p>Pass input through filter</p>
<pre class="codeinput">y = conv(b,x);
</pre>
<h2 id="15">3.1d)</h2>
<p>Plot output signal</p>
<pre class="codeinput">plot(0:39, y(1:40))
title(<span class="string">'Output'</span>)
ylabel(<span class="string">'y[n]'</span>)
xlabel(<span class="string">'n'</span>)
</pre>
<img vspace="5" hspace="5" src="main_01.png" alt=""> <p>Determine output signal by hand for n &gt;= 5</p>
<p>Taking the inverse z-transform of the transfer function determined in part 3.1a gives the function</p>
<p>y[n] = x[n] + (-2cos(0.7pi) - 2cos(0.44pi))x[n-1] + (2 + 4cos(0.44pi)cos(0.7pi))x[n-2] + (-2cos(0.44pi) - 2cos(0.7pi))x[n-3] + x[n-4]</p>
<p>Passing the input over 5 &lt;= n &lt;= 40 through this function</p>
<pre class="codeinput">y_hand = zeros(1,36);
<span class="keyword">for</span> i = 1:36
  y_hand(i) = x(i+5) + (-2*cos(0.7*pi) - 2*cos(0.44*pi))*x(i+5-1) + (2 + 4*cos(0.44*pi)*cos(0.7*pi))*x(i+5-2) + (-2*cos(0.44*pi) - 2*cos(0.7*pi))*x(i+5-3) + x(i+5-4);
<span class="keyword">end</span>
</pre>
<h2 id="20">3.1e)</h2>
<p>Plot convolved output overlayed with hand calculated output</p>
<pre class="codeinput">plot(0:39, y(1:40))
hold <span class="string">on</span>
stem(0:40, [zeros(1,5) y_hand])
hold <span class="string">off</span>
title(<span class="string">'Output Comparison'</span>)
ylabel(<span class="string">'y[n]'</span>)
xlabel(<span class="string">'n'</span>)
legend(<span class="string">'convolved'</span>, <span class="string">'hand'</span>)
</pre>
<img vspace="5" hspace="5" src="main_02.png" alt=""> <h2 id="21">3.1f)</h2>
<p>Our input signal is defined for n &gt;= 0 and our filter uses past input values back to x[n-4]. The start-up points at the beginning of the output are the points where those past values of x[n] are undefined by the input function and assummed to be 0. The sinusoidal output seen beginning at n = 5 is when the system can be properly "filled" with past x values. Having 4 start-up values is consistent with cascading two 2nd order filters into a 4th order filter.</p>
<pre class="codeinput">clear
</pre>
<h2 id="22">3.2a)</h2>
<p>Generate bandpass filter with w = 0.44pi</p>
<pre class="codeinput">L = 10;
wc = 0.44*pi;
n = [0:L];
b = 2/L*cos(wc*n);
</pre>
<p>Measure gain at frequencies of interest using DTFT</p>
<pre class="codeinput">gain1 = abs(sum(b.*exp(-1*j*0.3*pi*n)))
gain2 = abs(sum(b.*exp(-1*j*0.44*pi*n)))
gain3 = abs(sum(b.*exp(-1*j*0.7*pi*n)))
</pre>
<pre class="codeoutput">
gain1 =

    0.3113


gain2 =

    1.1161


gain3 =

    0.2337

</pre>
<h2 id="24">3.2b)</h2>
<p>Plot frequency response of the filter when L = 10, 20, 40</p>
<pre class="codeinput">
<span class="keyword">for</span> L = [10 20 40]
</pre>
<pre class="codeinput">n = [0:L];
b = 2/L*cos(wc*n);
ww = -pi:pi/10000:pi;   <span class="comment">%The number of samples here has to be quite large to find the passband limits with using a reasonable rounding</span>
H_mag = abs(freqz(b,1,ww)); <span class="comment">%Frequency response of filter</span>
ww = 0:pi/10000:pi;
H_mag = H_mag(10001:end);  <span class="comment">%Looking at positive side of frequency response</span>
plot(ww, H_mag)
xlim([0 pi])
hold <span class="string">on</span>
yline(max(H_mag)*0.707)
yline(max(H_mag)*0.25)
legend(<span class="string">'Frequency Response'</span>, <span class="string">'Passband'</span>, <span class="string">'Stopband'</span>)
hold <span class="string">off</span>
</pre>
<img vspace="5" hspace="5" src="main_03.png" alt=""> <img vspace="5" hspace="5" src="main_04.png" alt=""> <img vspace="5" hspace="5" src="main_05.png" alt=""> <p>Find passband width</p>
<pre class="codeinput">passband_limits = find(round(H_mag,2)==round(max(H_mag)*0.707,2));
passband_width = ww(max(passband_limits)) - ww(min(passband_limits))
</pre>
<pre class="codeoutput">
passband_width =

    0.5080

</pre>
<pre class="codeoutput">
passband_width =

    0.2614

</pre>
<pre class="codeoutput">
passband_width =

    0.1357

</pre>
<pre class="codeinput">
<span class="keyword">end</span>
</pre>
<p>Doubling the parameter L from 10, 20, 40 has halved the passband width from about 0.5, 0.26, 0.135. This verifies the property stated in the lab instructions, that the passband is inversely proportional to L.</p>
<h2 id="29">3.2c)</h2>
<h2 id="30">3.2d)</h2>
<h2 id="31">3.2e)</h2>
<h2 id="32">3.2f)</h2>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Frequency Response of FIR Filters: Lab P-12: 3 Lab Exercise

%% 3.1a)
% We will cascade these filters by convolution, which will be performed by
% multiplication of their transfer functions.
%% 
% First we'll find the transfer function of the general filter
%%
% Y(z) = X(z) - 2cos(wn)z^-1X(z) + z^-2X(z)
%%
% H(z) = 1 - 2cos(wn)z^-1 + z^-2
%%
% Now we'll introduce the nulling frequencies 0.44pi and 0.7pi
%%
% H1(z) = 1 - 2cos(0.44pi)z^-1 + z^-2
%%
% H2(z) = 1 - 2cos(0.7pi)z^-1 + z^-2
%%
% Performing the convolution
%%
% (1 - 2cos(0.44pi)z^-1 + z^-2)(1 - 2cos(0.44pi)z^-1 + z^-2)
%%
% Yields the fourth order filter
%%
% 1 + (-2cos(0.7pi) - 2cos(0.44pi)))z^-1 + (2 + 4cos(0.44pi)cos(0.7pi))z^-2
% + (-2cos(0.44pi) - 2cos(0.7pi))z^-3 + z^-4
%%
% Resulting in the following coefficients

b = [1 -2*cos(0.7*pi)-2*cos(0.44*pi) 2+4*cos(0.44*pi)*cos(0.7*pi) -2*cos(0.44*pi)-2*cos(0.7*pi) 1]

%% 3.1b)
% Generate input signal

n = [0:149];
x = 5*cos(0.3*pi*n) + 22*cos(0.44*pi*n-pi/3) + 22*cos(0.7*pi*n-pi/4);

%% 3.1c)
% Pass input through filter

y = conv(b,x);

%% 3.1d)
% Plot output signal

plot(0:39, y(1:40))
title('Output')
ylabel('y[n]')
xlabel('n')

%%
% Determine output signal by hand for n >= 5
%%
% Taking the inverse z-transform of the transfer function determined in
% part 3.1a gives the function
%%
% y[n] = x[n] + (-2cos(0.7pi) - 2cos(0.44pi))x[n-1] + (2 +
% 4cos(0.44pi)cos(0.7pi))x[n-2] + (-2cos(0.44pi) - 2cos(0.7pi))x[n-3] +
% x[n-4]
%%
% Passing the input over 5 <= n <= 40 through this function

y_hand = zeros(1,36);
for i = 1:36
  y_hand(i) = x(i+5) + (-2*cos(0.7*pi) - 2*cos(0.44*pi))*x(i+5-1) + (2 + 4*cos(0.44*pi)*cos(0.7*pi))*x(i+5-2) + (-2*cos(0.44*pi) - 2*cos(0.7*pi))*x(i+5-3) + x(i+5-4);
end

%% 3.1e)
% Plot convolved output overlayed with hand calculated output

plot(0:39, y(1:40))
hold on
stem(0:40, [zeros(1,5) y_hand])
hold off
title('Output Comparison')
ylabel('y[n]')
xlabel('n')
legend('convolved', 'hand')

%% 3.1f)
% Our input signal is defined for n >= 0 and our filter uses past input
% values back to x[n-4]. The start-up points at the beginning of the output
% are the points where those past values of x[n] are undefined by the input 
% function and assummed to be 0. The sinusoidal output seen beginning at 
% n = 5 is when the system can be properly "filled" with past x values. 
% Having 4 start-up values is consistent with cascading two 2nd order 
% filters into a 4th order filter.

clear

%% 3.2a)
% Generate bandpass filter with w = 0.44pi

L = 10;
wc = 0.44*pi;
n = [0:L];
b = 2/L*cos(wc*n);

%%
% Measure gain at frequencies of interest using DTFT

gain1 = abs(sum(b.*exp(-1*j*0.3*pi*n)))
gain2 = abs(sum(b.*exp(-1*j*0.44*pi*n)))
gain3 = abs(sum(b.*exp(-1*j*0.7*pi*n)))

%% 3.2b)
% Plot frequency response of the filter when L = 10, 20, 40

for L = [10 20 40]
n = [0:L];
b = 2/L*cos(wc*n);
ww = -pi:pi/10000:pi;   %The number of samples here has to be quite large to find the passband limits with using a reasonable rounding
H_mag = abs(freqz(b,1,ww)); %Frequency response of filter
ww = 0:pi/10000:pi;      
H_mag = H_mag(10001:end);  %Looking at positive side of frequency response
plot(ww, H_mag)
xlim([0 pi])
hold on
yline(max(H_mag)*0.707)
yline(max(H_mag)*0.25)
legend('Frequency Response', 'Passband', 'Stopband')
hold off

%%
% Find passband width

passband_limits = find(round(H_mag,2)==round(max(H_mag)*0.707,2));
passband_width = ww(max(passband_limits)) - ww(min(passband_limits))

end

%%
% Doubling the parameter L from 10, 20, 40 has halved the passband width
% from about 0.5, 0.26, 0.135. This verifies the property stated in the lab
% instructions, that the passband is inversely proportional to L.

%% 3.2c)
%

%% 3.2d)
%

%% 3.2e)
%

%% 3.2f)
%
##### SOURCE END #####
-->
</body>
</html>
